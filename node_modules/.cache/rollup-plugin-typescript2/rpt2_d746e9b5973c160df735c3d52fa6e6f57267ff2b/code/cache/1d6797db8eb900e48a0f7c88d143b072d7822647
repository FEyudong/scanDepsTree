{"code":"import fs from \"fs\";\r\nimport pathTools from \"path\";\r\nimport parser from \"@babel/parser\";\r\nimport traverse from \"@babel/traverse\";\r\nimport { parse as sfcParse, compileScript } from \"@vue/compiler-sfc\";\r\nimport { DEFAULT_EXTENSIONS } from \"./consts\";\r\nimport { isNpmPath } from \"./utils\";\r\nlet config_ = null;\r\n/**\r\n * 扫描依赖的入口函数\r\n * @returns DepTree\r\n */\r\nexport default function main(entry, config) {\r\n    const absPath = pathTools.resolve(entry);\r\n    config_ = {\r\n        skipTypeImport: true,\r\n        ...config\r\n    };\r\n    depTreeCacheMap.clear();\r\n    const depsTree = createDepsTree(absPath);\r\n    return depsTree;\r\n}\r\n// 依赖节点缓存\r\nconst depTreeCacheMap = new Map();\r\n/**\r\n * 创建依赖树\r\n * @param path 分析文件的路径\r\n * @returns DepTree\r\n */\r\nfunction createDepsTree(path) {\r\n    // 复用已解析过的依赖节点\r\n    if (depTreeCacheMap.has(path)) {\r\n        return depTreeCacheMap.get(path);\r\n    }\r\n    // 获取依赖\r\n    const deps = getDeps(path);\r\n    depTreeCacheMap.set(path, deps);\r\n    deps.forEach((item) => {\r\n        item.children = createDepsTree(item.localPath);\r\n    });\r\n    return deps;\r\n}\r\n/**\r\n * 获取文件依赖\r\n * @param cwf 当前工作文件路径\r\n * @returns 依赖数组\r\n */\r\nexport function getDeps(cwf) {\r\n    // console.log(\"cwf\", cwf);\r\n    // 利用babel的能力，查找文件中的import语句\r\n    const deps = [];\r\n    try {\r\n        let fileCode = fs.readFileSync(cwf).toString();\r\n        // 处理vue-sfc类型的文件\r\n        if (pathTools.extname(cwf) === \".vue\") {\r\n            const { descriptor, errors } = sfcParse(fileCode, {\r\n                sourceMap: false,\r\n                filename: cwf,\r\n            });\r\n            if (errors.length > 0) {\r\n                throw new Error(`解析vue文件出错,原因是:${errors.join(\"/n\")}`);\r\n            }\r\n            fileCode = compileScript(descriptor, {\r\n                id: cwf,\r\n                sourceMap: false,\r\n            }).content;\r\n        }\r\n        const ast = parser.parse(fileCode, {\r\n            plugins: [\r\n                \"typescript\",\r\n                \"jsx\",\r\n                [\r\n                    \"decorators\",\r\n                    {\r\n                        decoratorsBeforeExport: true,\r\n                    },\r\n                ],\r\n            ],\r\n        });\r\n        let importVars = [];\r\n        traverse.default(ast, {\r\n            enter(path) {\r\n                const node = path.node, scope = path.scope;\r\n                let importPath = \"\";\r\n                switch (node.type) {\r\n                    case \"ImportDeclaration\":\r\n                        // 跳过纯类型引用 import type xxx from 'xxx'\r\n                        if (config_.skipTypeImport && node.importKind !== \"value\") {\r\n                            break;\r\n                        }\r\n                        importPath = node?.source.value;\r\n                        // 排除未引用的导入变量\r\n                        importVars = node.specifiers\r\n                            .filter((item) => scope.bindings[item.local.name].referenced)\r\n                            .map((item) => ({\r\n                            type: item.type,\r\n                            name: item.type === \"ImportSpecifier\"\r\n                                ? item.imported.name\r\n                                : item.local.name,\r\n                        }));\r\n                        break;\r\n                    case \"CallExpression\":\r\n                        if (node.callee.type === \"Import\") {\r\n                            importPath = node.arguments[0]?.value;\r\n                        }\r\n                        break;\r\n                }\r\n                if (!importPath) {\r\n                    return;\r\n                }\r\n                // 排除npm包类型的依赖\r\n                if (isNpmPath(importPath)) {\r\n                    return;\r\n                }\r\n                // 排除一些无需进一步分析的文件类型，主要是一些资源文件\r\n                const extname = pathTools.extname(importPath);\r\n                if (extname && DEFAULT_EXTENSIONS.includes(extname) === false) {\r\n                    return;\r\n                }\r\n                const resolvedPath = transformImportPath(importPath, pathTools.dirname(cwf));\r\n                if (!resolvedPath) {\r\n                    return;\r\n                }\r\n                deps.push({\r\n                    path: resolvedPath.replace(process.cwd(), \"\"),\r\n                    localPath: resolvedPath,\r\n                    // shortPath: ,\r\n                    importVars,\r\n                });\r\n            },\r\n        });\r\n    }\r\n    catch (error) {\r\n        console.log(`已跳过${cwf},原因是:${error}`);\r\n    }\r\n    return deps;\r\n}\r\n/**\r\n * 处理源码中的import路径\r\n * @param importPath 源码文件路径\r\n * @param cwd 当前文件所处目录\r\n * @returns 绝对文件路径\r\n */\r\nfunction transformImportPath(importPath, cwd) {\r\n    if (isNpmPath(importPath)) {\r\n        return;\r\n    }\r\n    let _path = importPath;\r\n    // 应用路径别名 eg:@/utils/index\r\n    config_.resolveAlias &&\r\n        Object.entries(config_.resolveAlias).forEach(([k, v]) => {\r\n            _path = _path.replace(k, v);\r\n        });\r\n    // 兼容路径不完整的导入\r\n    if (!pathTools.extname(_path)) {\r\n        for (let i = 0; i < DEFAULT_EXTENSIONS.length; i++) {\r\n            const extName = DEFAULT_EXTENSIONS[i];\r\n            // eg: ./utils/index\r\n            const addExtPath = pathTools.resolve(cwd, `${_path}${extName}`);\r\n            // eg: ./utils\r\n            const addExtAndIndexPath = pathTools.resolve(cwd, `${_path}/index${extName}`);\r\n            if (fs.existsSync(addExtPath)) {\r\n                _path = addExtPath;\r\n                break;\r\n            }\r\n            else if (fs.existsSync(addExtAndIndexPath)) {\r\n                _path = addExtAndIndexPath;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return pathTools.resolve(cwd, _path);\r\n}\r\n","references":["/Users/a58/work/code_space/test/scanDepsTree/node_modules/@babel/parser/typings/babel-parser.d.ts","/Users/a58/work/code_space/test/scanDepsTree/node_modules/@babel/traverse/lib/index.js","/Users/a58/work/code_space/test/scanDepsTree/node_modules/@vue/compiler-sfc/dist/compiler-sfc.d.ts","/Users/a58/work/code_space/test/scanDepsTree/src/consts.ts","/Users/a58/work/code_space/test/scanDepsTree/src/utils.ts","/Users/a58/work/code_space/test/scanDepsTree/src/types/index.ts","/Users/a58/work/code_space/test/scanDepsTree/src/types/config.ts"],"dts":{"name":"/Users/a58/work/code_space/test/scanDepsTree/node_modules/.cache/rollup-plugin-typescript2/placeholder/index.d.ts","writeByteOrderMark":false,"text":"import type { DepTree } from \"./types/index\";\r\nimport { Config } from \"./types/config\";\r\n/**\r\n * 扫描依赖的入口函数\r\n * @returns DepTree\r\n */\r\nexport default function main(entry: string, config: Config): DepTree;\r\n/**\r\n * 获取文件依赖\r\n * @param cwf 当前工作文件路径\r\n * @returns 依赖数组\r\n */\r\nexport declare function getDeps(cwf: string): any[];\r\n"}}
